{"version":3,"file":"LWWMap.js","sources":["../src/LWWMap.ts"],"sourcesContent":["  import * as Y         from 'yjs'\n  import { Observable } from 'lib0/observable.js'\n  import md5            from 'blueimp-md5'\n\n  const TimestampFactor = 3000              // expected max. # of changes per ms\n         // however, having even more changes does not break this implementation\n\n  type ChangeLogEntry<T> = {              // represents a change of an LWWMap entry\n    Key:string,\n    Value?:T,\n    Timestamp:number\n  }\n\n// handling of deleted entries:\n// - entries in this.localMap and this.sharedArray with missing \"Value\" property\n//   such entries will be removed \"RetentionPeriod\" ms after deletion\n\n  export class LWWMap<T extends object|boolean|Array<T>|string|number|null|Uint8Array> extends Observable<T> {\n    protected RetentionPeriod:number    // how long to keep deletion log entries\n    protected sharedArray:any  // elements with higher indices where added later\n    protected sharedDoc:any\n    protected localMap:Map<string,ChangeLogEntry<T>> // caches validated changes\n    protected lastTimestamp:number       // keeps track of most recent timestamp\n\n    public constructor (\n      sharedArray:Y.Array<{ key: string, val: T }>,\n      RetentionPeriod:number = 30*24*60*60*1000\n    ) {\n      super()\n\n      this.sharedArray = sharedArray       // this is the actually shared object\n      this.sharedDoc   = sharedArray.doc\n\n      this.RetentionPeriod = RetentionPeriod * TimestampFactor\n      this.lastTimestamp   = Date.now()      * TimestampFactor\n\n      this.localMap = new Map<string,ChangeLogEntry<T>>()\n      this._initializeMap()\n\n    /**** \"sharedArray\" is where synchronization happens, observe it ****/\n\n      this.sharedArray.observe(\n        (Event:any,Transaction:any) => this._updateOnChange(Event,Transaction)\n      )\n    }\n\n  /**** @@iterator ****/\n\n    public [Symbol.iterator]():IterableIterator<T> {\n      return (\n        [...this.localMap.entries()]\n        .filter((Entry) => 'Value' in Entry[1])\n        .map((Entry) => [Entry[0],Entry[1].Value])\n      )[Symbol.iterator]() as IterableIterator<T>\n    }\n\n  /**** size ****/\n\n    public get size ():number {\n      let Result:number = 0\n        this.localMap.forEach((loggedEntry:ChangeLogEntry<T>) => {\n          if ('Value' in loggedEntry) { Result++ }\n        })\n      return Result\n    }\n\n  /**** clear ****/\n\n    public clear ():void {\n      if (this.size > 0) {\n        this.sharedDoc.transact(() => {\n          this._removeAnyObsoleteDeletions()    // from localMap and sharedArray\n\n          this.sharedArray.delete(0,this.sharedArray.length)\n\n          this.localMap.forEach((loggedEntry:ChangeLogEntry<T>, Key:string) => {\n            if ('Value' in loggedEntry) {\n              this._updateLastTimestampWith(Date.now() * TimestampFactor)\n              let Change:ChangeLogEntry<T> = { Key, Timestamp:this.lastTimestamp }\n\n              this.localMap.set(Key,Change)\n              this.sharedArray.push([Change])\n            } else {\n              this.sharedArray.push([loggedEntry])\n            }\n          })\n        })\n      }\n    }\n\n  /**** delete ****/\n\n    public delete (Key:string):boolean {\n      if (this.localMap.has(Key)) {       // ignore deletions of missing entries\n        this.sharedDoc.transact(() => {\n          this._removeAnyLogEntriesForKey(Key)\n          this._removeAnyObsoleteDeletions()\n\n          this._updateLastTimestampWith(Date.now() * TimestampFactor)\n          let Change:ChangeLogEntry<T> = { Key, Timestamp:this.lastTimestamp }\n\n          this.localMap.set(Key,Change)\n          this.sharedArray.push([Change])\n        })\n\n        return true\n      } else {\n        return false\n      }\n    }\n\n  /**** entries ****/\n\n    public entries ():IterableIterator<[string, T]> {\n      const localMapEntries = this.localMap.entries()\n\n      return {\n        [Symbol.iterator]() { return this },       // makes this object iterable\n\n// @ts-ignore TS2322\n        next: ():{ value?:[string,T], done?:boolean } => {\n          let nextEntry = localMapEntries.next()\n          while (! nextEntry.done) {\n            let [Key,loggedChange] = nextEntry.value\n            if ('Value' in loggedChange) {\n              return { value:[Key,loggedChange.Value as T] }\n            } else {\n              nextEntry = localMapEntries.next()\n            }\n          }\n          return { done:true }\n        }\n      }\n    }\n\n  /**** forEach ****/\n\n    public forEach (Callback:(Value:T, Key:string, Map:LWWMap<T>) => void, thisArg?:any):void {\n      this.localMap.forEach((loggedEntry:ChangeLogEntry<T>,Key:string) => {\n        if ('Value' in loggedEntry) {     // ignore entries describing deletions\n          Callback.call(thisArg, loggedEntry.Value as T, Key, this)\n        }\n      })\n    }\n\n  /**** get ****/\n\n    public get (Key:string):T | undefined {\n      return (\n        this.localMap.has(Key)\n        ? (this.localMap.get(Key) as ChangeLogEntry<T>).Value\n        : undefined\n      )\n    }\n\n  /**** has ****/\n\n    public has (Key:string):boolean {\n      return (\n        this.localMap.has(Key) &&\n        ('Value' in (this.localMap.get(Key) as ChangeLogEntry<T>))\n      )\n    }\n\n  /**** keys ****/\n\n    public keys ():IterableIterator<string> {\n      const localMapEntries = this.localMap.entries()\n\n      return {\n        [Symbol.iterator]() { return this },       // makes this object iterable\n\n// @ts-ignore TS2322\n        next: ():{ value?:string, done?:boolean } => {\n          let nextEntry = localMapEntries.next()\n          while (! nextEntry.done) {\n            let [Key,loggedChange] = nextEntry.value\n            if ('Value' in loggedChange) {\n              return { value:Key }\n            } else {\n              nextEntry = localMapEntries.next()\n            }\n          }\n          return { done:true }\n        }\n      }\n    }\n\n  /**** set ****/\n\n    public set (Key:string, Value:T):void {\n      this.sharedDoc.transact(() => {\n        this._removeAnyLogEntriesForKey(Key)\n        this._removeAnyObsoleteDeletions()\n\n        this._updateLastTimestampWith(Date.now() * TimestampFactor)\n        let Change = { Key, Value, Timestamp:this.lastTimestamp }\n\n        this.localMap.set(Key,Change)\n        this.sharedArray.push([Change])\n      })\n    }\n\n  /**** values ****/\n\n    public values ():IterableIterator<T> {\n      const localMapEntries = this.localMap.entries()\n\n      return {\n        [Symbol.iterator]() { return this },       // makes this object iterable\n\n// @ts-ignore TS2322\n        next: ():{ value?:T, done?:boolean } => {\n          let nextEntry = localMapEntries.next()\n          while (! nextEntry.done) {\n            let [Key,loggedChange] = nextEntry.value\n            if ('Value' in loggedChange) {\n              return { value:loggedChange.Value as T }\n            } else {\n              nextEntry = localMapEntries.next()\n            }\n          }\n          return { done:true }\n        }\n      }\n    }\n\n  /**** transact ****/\n\n    public transact (Callback:(Transaction:any) => void, Origin?:any):void {\n      this.sharedDoc.transact(Callback,Origin)\n    }\n\n  /**** Container ****/\n\n    public get Container ():Y.Array<{ key: string, val: T }> {\n      return this.sharedArray\n    }\n\n  /**** _LogEntryIsBroken ****/\n\n    protected _LogEntryIsBroken (LogEntry:any):boolean {\n      return (\n        (LogEntry == null) ||\n        (typeof LogEntry.Key !== 'string') ||\n        (typeof LogEntry.Timestamp !== 'number') ||\n        ! isFinite(LogEntry.Timestamp) || (LogEntry.Timestamp < 0) ||\n        (Math.floor(LogEntry.Timestamp) !== LogEntry.Timestamp)\n      )\n    }\n\n  /**** _ChangesCollide - is \"firstChange\" newer than \"secondChange\"? ****/\n\n    private _md5Hash (Value:any):string {\n      try {\n        return md5(JSON.stringify(Value))\n      } catch (Signal:any) {\n        return ''\n      }\n    }\n\n    protected _ChangesCollide (\n      firstChange:ChangeLogEntry<T>, secondChange:ChangeLogEntry<T>\n    ):boolean {\n      return (\n        (firstChange.Timestamp > secondChange.Timestamp) ||\n        (\n          (firstChange.Timestamp === secondChange.Timestamp) &&\n          (firstChange.Value !== secondChange.Value) &&\n          (this._md5Hash(firstChange.Value) > this._md5Hash(secondChange.Value))\n        )                // consistent behaviour in case of timestamp collisions\n      )\n    }\n\n  /**** initialize \"localMap\" from \"sharedArray\", remove obsolete array items ****/\n\n    protected _initializeMap ():void {\n      const DeletionSet = new Map()              // keeps track of deletion logs\n\n      const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n      this.sharedDoc.transact(() => {\n        for (let i = ChangeLog.length-1; i >= 0; i--) {// backwards for deletion\n          const loggedChange:ChangeLogEntry<T> = ChangeLog[i]\n\n          const Key          = loggedChange.Key\n          const KeyIsKnown   = this.localMap.has(Key) || DeletionSet.has(Key)\n          const cachedChange = (\n            KeyIsKnown\n            ? this.localMap.get(Key) || DeletionSet.get(Key)\n            : undefined\n          )\n\n          if ('Value' in loggedChange) {// \"loggedChange\" defines existing entry\n            switch (true) {\n              case ! KeyIsKnown:\n                this.localMap.set(Key,loggedChange)\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n                break\n              case this._ChangesCollide(cachedChange,loggedChange):\n                console.warn(\n                  'LWWMap: timestamp mismatch for key \"' + Key + '\"'\n                )\n                this.sharedArray.delete(i)          // remove obsolete log entry\n                break\n              default:      // entry is already known, but its state is outdated\n                DeletionSet.delete(Key)                       // just in case...\n\n                this.localMap.set(Key,loggedChange)\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n            }        // the older ChangeLog entry will persist until next update\n          } else {                     // \"loggedChange\" defines a deleted entry\n            switch (true) {\n              case ! KeyIsKnown:\n                DeletionSet.set(Key,loggedChange)\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n                break\n              case this._ChangesCollide(cachedChange,loggedChange):\n                console.warn(\n                  'LWWMap: timestamp mismatch for key \"' + Key + '\"'\n                )\n                this.sharedArray.delete(i)          // remove obsolete log entry\n                break\n              default:      // entry is already known, but its state is outdated\n                DeletionSet.set(Key,loggedChange)\n\n                this.localMap.delete(Key)                     // just in case...\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n            }        // the older ChangeLog entry will persist until next update\n          }\n        }\n      })\n    }\n\n  /**** apply reported updates - if applicable ****/\n\n    protected _updateOnChange (Event:any,Transaction:any):void {\n      const TransactionLog  = new Map()  // verified updates in this transaction\n      let   TransactionTime = this.lastTimestamp          // temporary timestamp\n      const EventLog        = new Map()           // prepares final change event\n\n    /**** updateTransactionTimeWith ****/\n\n      function updateTransactionTimeWith (newTimestamp:number):void {\n        TransactionTime = Math.max(TransactionTime,newTimestamp)\n        if (TransactionTime >= Number.MAX_SAFE_INTEGER) {\n          throw new TypeError('timestamp has reached the allowed limit')\n        }\n      }\n\n    /**** analyze all updates in this transaction ****/\n\n      const UpdateLog:ChangeLogEntry<T>[] = Array.from(Event.changes.added).map(\n        (addedContent:any) => addedContent.content.getContent()\n      ).flat()                      // updates are appended sharedArray elements\n\n      try {\n        UpdateLog.forEach((loggedUpdate:ChangeLogEntry<T>) => {\n          if (this._LogEntryIsBroken(loggedUpdate)) { return } // skip broken logs\n\n          const Key          = loggedUpdate.Key\n          const KeyIsKnown   = EventLog.has(Key) || this.localMap.has(Key)\n          const cachedUpdate = (\n            KeyIsKnown\n            ? EventLog.get(Key) || this.localMap.get(Key)\n            : undefined\n          )\n\n          switch (true) {\n            case ! ('Value' in loggedUpdate):    // log entry defines a deletion\n              if (KeyIsKnown) {           // actually delete cached entries only\n                if (this._ChangesCollide(cachedUpdate,loggedUpdate)) {\n                  throw new Error('Conflict: remotely deleted entry was modified locally')\n                }\n\n                updateTransactionTimeWith(loggedUpdate.Timestamp)\n\n                TransactionLog.set(Key,loggedUpdate)\n                EventLog.set(Key, {\n                  action:'delete', oldValue:cachedUpdate.Value\n                })\n              }\n              break\n            case KeyIsKnown && this._ChangesCollide(cachedUpdate,loggedUpdate):\n              throw new Error('Conflict: remote change is outdated')\n            default:                                      // everything seems ok\n              updateTransactionTimeWith(loggedUpdate.Timestamp)\n\n              TransactionLog.set(Key,loggedUpdate)\n              if (this.localMap.has(Key)) {             // not just \"KeyIsKnown\"\n                EventLog.set(Key, {\n                  action:'update', oldValue:cachedUpdate.Value, newValue:loggedUpdate.Value\n                })\n              } else {\n                EventLog.set(Key, {\n                  action:'add', newValue:loggedUpdate.Value\n                })\n              }\n          }\n        })\n      } catch (Signal:any) { // refresh affected entries to keep them consistent\n        if (Signal.message.startsWith('Conflict: ')) {\n          const KeysToRefresh   = new Set()\n          const ChangesToDelete = new Set()\n\n          UpdateLog.forEach((loggedUpdate) => {\n            KeysToRefresh.add(loggedUpdate.Key)      // refresh affected entries\n            ChangesToDelete.add(loggedUpdate) // remove inconsistent change logs\n          })\n\n          const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n          this.sharedDoc.transact(() => {\n            const ChangesToRefresh = new Map()\n\n          /**** remove any obsolete ChangeLog entries... ****/\n\n            for (let i = ChangeLog.length-1; i >= 0; i--) {// backw. for deletion\n              let loggedChange = ChangeLog[i]\n              let Key          = loggedChange.Key\n\n              switch (true) {\n                case ChangesToDelete.has(loggedChange):\n                  this.sharedArray.delete(i)\n                  break\n                case KeysToRefresh.has(Key):\n                  if (! ChangesToRefresh.has(Key)) {\n                    ChangesToRefresh.set(Key,loggedChange)\n                  }   // \"ChangesToRefresh\" will only store latest logged change\n                  this.sharedArray.delete(i)\n              }\n            }\n\n          /**** ...and reappend those that should be refreshed ****/\n\n            for (const [Key,loggedChange] of ChangesToRefresh) {\n              this.sharedArray.push([loggedChange])\n            }\n          })\n\n          return                                 // no updates have been applied\n        } else {\n          throw Signal                       // do not swallow \"real\" exceptions\n        }\n      }\n\n    /**** now actually apply any updates ****/\n\n      if (EventLog.size > 0) {\n        for (const [Key,loggedUpdate] of TransactionLog) {\n          this.localMap.set(Key,loggedUpdate)\n        }\n        this.lastTimestamp = TransactionTime\n      }\n\n    /**** finally try to optimize the current ChangeLog ****/\n\n      this._removeAnyBrokenLogEntries()\n      this._removeAnyObsoleteDeletions()\n\n      if (EventLog.size > 0) {\n        const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n        this.sharedDoc.transact(() => {\n          for (let i = ChangeLog.length-1; i >= 0; i--) { // backw. for deletion\n            const loggedChange = ChangeLog[i]\n            const Key          = loggedChange.Key\n            if (EventLog.has(Key) && (EventLog.get(Key).newValue !== loggedChange.Value)) {\n              this.sharedArray.delete(i)\n            }\n          }\n        })\n      }\n\n    /**** it's time to inform the client ****/\n\n      if (EventLog.size > 0) {\n// @ts-ignore TS2339\n        this.emit('change',[EventLog,Transaction])\n      }\n    }\n\n  /**** _removeAnyBrokenLogEntries ****/\n\n    protected _removeAnyBrokenLogEntries ():void {\n      const ChangeLog:any[] = this.sharedArray.toArray()\n      for (let i = ChangeLog.length-1; i >= 0; i--) {\n        const loggedChange:any = ChangeLog[i]\n        if (this._LogEntryIsBroken(loggedChange)) {\n          this.sharedArray.delete(i)\n        }\n      }\n    }\n\n  /**** _removeAnyLogEntriesForKey ****/\n\n    protected _removeAnyLogEntriesForKey (Key:string):void {\n      const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n      for (let i = ChangeLog.length-1; i >= 0; i--) {\n        const loggedChange:ChangeLogEntry<T> = ChangeLog[i]\n        if (loggedChange.Key === Key) {\n          this.sharedArray.delete(i)\n        }\n      }\n    }\n\n  /**** _removeAnyObsoleteDeletions ****/\n\n    protected _removeAnyObsoleteDeletions ():void {\n      let RetentionTimestamp = Date.now() * TimestampFactor - this.RetentionPeriod\n\n      const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n      for (let i = ChangeLog.length-1; i >= 0; i--) {\n        const loggedChange:ChangeLogEntry<T> = ChangeLog[i]\n        if (\n          ! ('Value' in loggedChange) &&\n          (loggedChange.Timestamp < RetentionTimestamp)\n        ) {\n          this.localMap.delete(loggedChange.Key)\n          this.sharedArray.delete(i)\n        }\n      }\n    }\n\n  /**** _updateLastTimestampWith ****/\n\n    protected _updateLastTimestampWith (Timestamp:number):void {\n      let newTimestamp:number = Math.max(this.lastTimestamp + 1, Timestamp)\n      if (newTimestamp >= Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('timestamp has reached the allowed limit')\n      } else {\n        this.lastTimestamp = newTimestamp\n      }\n    }\n  }\n"],"names":["TimestampFactor","LWWMap","Observable","constructor","sharedArray","RetentionPeriod","super","this","sharedDoc","doc","lastTimestamp","Date","now","localMap","Map","_initializeMap","observe","Event","Transaction","_updateOnChange","Symbol","iterator","entries","filter","Entry","map","Value","size","Result","forEach","loggedEntry","clear","transact","_removeAnyObsoleteDeletions","delete","length","Key","_updateLastTimestampWith","Change","Timestamp","set","push","has","_removeAnyLogEntriesForKey","localMapEntries","next","nextEntry","done","loggedChange","value","Callback","thisArg","call","get","undefined","keys","values","Origin","Container","_LogEntryIsBroken","LogEntry","isFinite","Math","floor","_md5Hash","md5","JSON","stringify","Signal","_ChangesCollide","firstChange","secondChange","DeletionSet","ChangeLog","toArray","i","KeyIsKnown","cachedChange","console","warn","TransactionLog","TransactionTime","EventLog","updateTransactionTimeWith","newTimestamp","max","Number","MAX_SAFE_INTEGER","TypeError","UpdateLog","Array","from","changes","added","addedContent","content","getContent","flat","loggedUpdate","cachedUpdate","Error","action","oldValue","newValue","message","startsWith","KeysToRefresh","Set","ChangesToDelete","add","ChangesToRefresh","_removeAnyBrokenLogEntries","emit","RetentionTimestamp"],"mappings":"mbAIE,MAAMA,EAAkB,IAalB,MAAOC,UAAgFC,EAAAA,WAO3F,WAAAC,CACEC,EACAC,EAAyB,QAEzBC,QAEAC,KAAKH,YAAcA,EACnBG,KAAKC,UAAcJ,EAAYK,IAE/BF,KAAKF,gBAAkBA,EAAkBL,EACzCO,KAAKG,cAAkBC,KAAKC,MAAaZ,EAEzCO,KAAKM,SAAW,IAAIC,IACpBP,KAAKQ,iBAILR,KAAKH,YAAYY,SACf,CAACC,EAAUC,IAAoBX,KAAKY,gBAAgBF,EAAMC,IAE7D,CAIM,CAACE,OAAOC,YACb,MACE,IAAId,KAAKM,SAASS,WACjBC,QAAQC,GAAU,UAAWA,EAAM,KACnCC,KAAKD,GAAU,CAACA,EAAM,GAAGA,EAAM,GAAGE,SACnCN,OAAOC,WACV,CAID,QAAWM,GACT,IAAIC,EAAgB,EAIpB,OAHErB,KAAKM,SAASgB,SAASC,IACjB,UAAWA,GAAeF,GAAU,IAErCA,CACR,CAIM,KAAAG,GACDxB,KAAKoB,KAAO,GACdpB,KAAKC,UAAUwB,UAAS,KACtBzB,KAAK0B,8BAEL1B,KAAKH,YAAY8B,OAAO,EAAE3B,KAAKH,YAAY+B,QAE3C5B,KAAKM,SAASgB,SAAQ,CAACC,EAA+BM,KACpD,GAAI,UAAWN,EAAa,CAC1BvB,KAAK8B,yBAAyB1B,KAAKC,MAAQZ,GAC3C,IAAIsC,EAA2B,CAAEF,MAAKG,UAAUhC,KAAKG,eAErDH,KAAKM,SAAS2B,IAAIJ,EAAIE,GACtB/B,KAAKH,YAAYqC,KAAK,CAACH,GACxB,MACC/B,KAAKH,YAAYqC,KAAK,CAACX,GACxB,GACD,GAGP,CAIM,OAAQM,GACb,QAAI7B,KAAKM,SAAS6B,IAAIN,KACpB7B,KAAKC,UAAUwB,UAAS,KACtBzB,KAAKoC,2BAA2BP,GAChC7B,KAAK0B,8BAEL1B,KAAK8B,yBAAyB1B,KAAKC,MAAQZ,GAC3C,IAAIsC,EAA2B,CAAEF,MAAKG,UAAUhC,KAAKG,eAErDH,KAAKM,SAAS2B,IAAIJ,EAAIE,GACtB/B,KAAKH,YAAYqC,KAAK,CAACH,GAAQ,KAG1B,EAIV,CAIM,OAAAhB,GACL,MAAMsB,EAAkBrC,KAAKM,SAASS,UAEtC,MAAO,CACL,CAACF,OAAOC,YAAc,OAAOd,IAAM,EAGnCsC,KAAM,KACJ,IAAIC,EAAYF,EAAgBC,OAChC,MAASC,EAAUC,MAAM,CACvB,IAAKX,EAAIY,GAAgBF,EAAUG,MACnC,GAAI,UAAWD,EACb,MAAO,CAAEC,MAAM,CAACb,EAAIY,EAAatB,QAEjCoB,EAAYF,EAAgBC,MAE/B,CACD,MAAO,CAAEE,MAAK,EAAM,EAGzB,CAIM,OAAAlB,CAASqB,EAAuDC,GACrE5C,KAAKM,SAASgB,SAAQ,CAACC,EAA8BM,KAC/C,UAAWN,GACboB,EAASE,KAAKD,EAASrB,EAAYJ,MAAYU,EAAK7B,KACrD,GAEJ,CAIM,GAAA8C,CAAKjB,GACV,OACE7B,KAAKM,SAAS6B,IAAIN,GACf7B,KAAKM,SAASwC,IAAIjB,GAA2BV,WAC9C4B,CAEL,CAIM,GAAAZ,CAAKN,GACV,OACE7B,KAAKM,SAAS6B,IAAIN,IACjB,UAAY7B,KAAKM,SAASwC,IAAIjB,EAElC,CAIM,IAAAmB,GACL,MAAMX,EAAkBrC,KAAKM,SAASS,UAEtC,MAAO,CACL,CAACF,OAAOC,YAAc,OAAOd,IAAM,EAGnCsC,KAAM,KACJ,IAAIC,EAAYF,EAAgBC,OAChC,MAASC,EAAUC,MAAM,CACvB,IAAKX,EAAIY,GAAgBF,EAAUG,MACnC,GAAI,UAAWD,EACb,MAAO,CAAEC,MAAMb,GAEfU,EAAYF,EAAgBC,MAE/B,CACD,MAAO,CAAEE,MAAK,EAAM,EAGzB,CAIM,GAAAP,CAAKJ,EAAYV,GACtBnB,KAAKC,UAAUwB,UAAS,KACtBzB,KAAKoC,2BAA2BP,GAChC7B,KAAK0B,8BAEL1B,KAAK8B,yBAAyB1B,KAAKC,MAAQZ,GAC3C,IAAIsC,EAAS,CAAEF,MAAKV,QAAOa,UAAUhC,KAAKG,eAE1CH,KAAKM,SAAS2B,IAAIJ,EAAIE,GACtB/B,KAAKH,YAAYqC,KAAK,CAACH,GAAQ,GAElC,CAIM,MAAAkB,GACL,MAAMZ,EAAkBrC,KAAKM,SAASS,UAEtC,MAAO,CACL,CAACF,OAAOC,YAAc,OAAOd,IAAM,EAGnCsC,KAAM,KACJ,IAAIC,EAAYF,EAAgBC,OAChC,MAASC,EAAUC,MAAM,CACvB,IAAKX,EAAIY,GAAgBF,EAAUG,MACnC,GAAI,UAAWD,EACb,MAAO,CAAEC,MAAMD,EAAatB,OAE5BoB,EAAYF,EAAgBC,MAE/B,CACD,MAAO,CAAEE,MAAK,EAAM,EAGzB,CAIM,QAAAf,CAAUkB,EAAoCO,GACnDlD,KAAKC,UAAUwB,SAASkB,EAASO,EAClC,CAID,aAAWC,GACT,OAAOnD,KAAKH,WACb,CAIS,iBAAAuD,CAAmBC,GAC3B,OACe,MAAZA,GACwB,iBAAjBA,EAASxB,KACc,iBAAvBwB,EAASrB,YACfsB,SAASD,EAASrB,YAAeqB,EAASrB,UAAY,GACvDuB,KAAKC,MAAMH,EAASrB,aAAeqB,EAASrB,SAEhD,CAIO,QAAAyB,CAAUtC,GAChB,IACE,OAAOuC,EAAG,QAACC,KAAKC,UAAUzC,GAC3B,CAAC,MAAO0C,GACP,MAAO,EACR,CACF,CAES,eAAAC,CACRC,EAA+BC,GAE/B,OACGD,EAAY/B,UAAYgC,EAAahC,WAEnC+B,EAAY/B,YAAcgC,EAAahC,WACvC+B,EAAY5C,QAAU6C,EAAa7C,OACnCnB,KAAKyD,SAASM,EAAY5C,OAASnB,KAAKyD,SAASO,EAAa7C,MAGpE,CAIS,cAAAX,GACR,MAAMyD,EAAc,IAAI1D,IAElB2D,EAAgClE,KAAKH,YAAYsE,UACvDnE,KAAKC,UAAUwB,UAAS,KACtB,IAAK,IAAI2C,EAAIF,EAAUtC,OAAO,EAAGwC,GAAK,EAAGA,IAAK,CAC5C,MAAM3B,EAAiCyB,EAAUE,GAE3CvC,EAAeY,EAAaZ,IAC5BwC,EAAerE,KAAKM,SAAS6B,IAAIN,IAAQoC,EAAY9B,IAAIN,GACzDyC,EACJD,EACErE,KAAKM,SAASwC,IAAIjB,IAAQoC,EAAYnB,IAAIjB,QAC1CkB,EAGJ,GAAI,UAAWN,EACb,QAAQ,GACN,KAAO4B,EACLrE,KAAKM,SAAS2B,IAAIJ,EAAIY,GACtBzC,KAAK8B,yBAAyBW,EAAaT,WAC3C,MACF,KAAKhC,KAAK8D,gBAAgBQ,EAAa7B,GACrC8B,QAAQC,KACN,uCAAyC3C,EAAM,KAEjD7B,KAAKH,YAAY8B,OAAOyC,GACxB,MACF,QACEH,EAAYtC,OAAOE,GAEnB7B,KAAKM,SAAS2B,IAAIJ,EAAIY,GACtBzC,KAAK8B,yBAAyBW,EAAaT,gBAG/C,QAAQ,GACN,KAAOqC,EACLJ,EAAYhC,IAAIJ,EAAIY,GACpBzC,KAAK8B,yBAAyBW,EAAaT,WAC3C,MACF,KAAKhC,KAAK8D,gBAAgBQ,EAAa7B,GACrC8B,QAAQC,KACN,uCAAyC3C,EAAM,KAEjD7B,KAAKH,YAAY8B,OAAOyC,GACxB,MACF,QACEH,EAAYhC,IAAIJ,EAAIY,GAEpBzC,KAAKM,SAASqB,OAAOE,GACrB7B,KAAK8B,yBAAyBW,EAAaT,WAGlD,IAEJ,CAIS,eAAApB,CAAiBF,EAAUC,GACnC,MAAM8D,EAAkB,IAAIlE,IAC5B,IAAMmE,EAAkB1E,KAAKG,cAC7B,MAAMwE,EAAkB,IAAIpE,IAI5B,SAASqE,EAA2BC,GAElC,GADAH,EAAkBnB,KAAKuB,IAAIJ,EAAgBG,GACvCH,GAAmBK,OAAOC,iBAC5B,MAAM,IAAIC,UAAU,0CAEvB,CAID,MAAMC,EAAgCC,MAAMC,KAAK1E,EAAM2E,QAAQC,OAAOpE,KACnEqE,GAAqBA,EAAaC,QAAQC,eAC3CC,OAEF,IACER,EAAU5D,SAASqE,IACjB,GAAI3F,KAAKoD,kBAAkBuC,GAAiB,OAE5C,MAAM9D,EAAe8D,EAAa9D,IAC5BwC,EAAeM,EAASxC,IAAIN,IAAQ7B,KAAKM,SAAS6B,IAAIN,GACtD+D,EACJvB,EACEM,EAAS7B,IAAIjB,IAAQ7B,KAAKM,SAASwC,IAAIjB,QACvCkB,EAGJ,QAAQ,GACN,MAAQ,UAAW4C,GACjB,GAAItB,EAAY,CACd,GAAIrE,KAAK8D,gBAAgB8B,EAAaD,GACpC,MAAM,IAAIE,MAAM,yDAGlBjB,EAA0Be,EAAa3D,WAEvCyC,EAAexC,IAAIJ,EAAI8D,GACvBhB,EAAS1C,IAAIJ,EAAK,CAChBiE,OAAO,SAAUC,SAASH,EAAazE,OAE1C,CACD,MACF,KAAKkD,GAAcrE,KAAK8D,gBAAgB8B,EAAaD,GACnD,MAAM,IAAIE,MAAM,uCAClB,QACEjB,EAA0Be,EAAa3D,WAEvCyC,EAAexC,IAAIJ,EAAI8D,GACnB3F,KAAKM,SAAS6B,IAAIN,GACpB8C,EAAS1C,IAAIJ,EAAK,CAChBiE,OAAO,SAAUC,SAASH,EAAazE,MAAO6E,SAASL,EAAaxE,QAGtEwD,EAAS1C,IAAIJ,EAAK,CAChBiE,OAAO,MAAOE,SAASL,EAAaxE,QAG3C,GAEJ,CAAC,MAAO0C,GACP,GAAIA,EAAOoC,QAAQC,WAAW,cAAe,CAC3C,MAAMC,EAAkB,IAAIC,IACtBC,EAAkB,IAAID,IAE5BlB,EAAU5D,SAASqE,IACjBQ,EAAcG,IAAIX,EAAa9D,KAC/BwE,EAAgBC,IAAIX,EAAa,IAGnC,MAAMzB,EAAgClE,KAAKH,YAAYsE,UA6BvD,YA5BAnE,KAAKC,UAAUwB,UAAS,KACtB,MAAM8E,EAAmB,IAAIhG,IAI7B,IAAK,IAAI6D,EAAIF,EAAUtC,OAAO,EAAGwC,GAAK,EAAGA,IAAK,CAC5C,IAAI3B,EAAeyB,EAAUE,GACzBvC,EAAeY,EAAaZ,IAEhC,QAAQ,GACN,KAAKwE,EAAgBlE,IAAIM,GACvBzC,KAAKH,YAAY8B,OAAOyC,GACxB,MACF,KAAK+B,EAAchE,IAAIN,GACf0E,EAAiBpE,IAAIN,IACzB0E,EAAiBtE,IAAIJ,EAAIY,GAE3BzC,KAAKH,YAAY8B,OAAOyC,GAE7B,CAID,IAAK,MAAOvC,EAAIY,KAAiB8D,EAC/BvG,KAAKH,YAAYqC,KAAK,CAACO,GACxB,GAIJ,CACC,MAAMoB,CAET,CAID,GAAIc,EAASvD,KAAO,EAAG,CACrB,IAAK,MAAOS,EAAI8D,KAAiBlB,EAC/BzE,KAAKM,SAAS2B,IAAIJ,EAAI8D,GAExB3F,KAAKG,cAAgBuE,CACtB,CAOD,GAHA1E,KAAKwG,6BACLxG,KAAK0B,8BAEDiD,EAASvD,KAAO,EAAG,CACrB,MAAM8C,EAAgClE,KAAKH,YAAYsE,UACvDnE,KAAKC,UAAUwB,UAAS,KACtB,IAAK,IAAI2C,EAAIF,EAAUtC,OAAO,EAAGwC,GAAK,EAAGA,IAAK,CAC5C,MAAM3B,EAAeyB,EAAUE,GACzBvC,EAAeY,EAAaZ,IAC9B8C,EAASxC,IAAIN,IAAS8C,EAAS7B,IAAIjB,GAAKmE,WAAavD,EAAatB,OACpEnB,KAAKH,YAAY8B,OAAOyC,EAE3B,IAEJ,CAIGO,EAASvD,KAAO,GAElBpB,KAAKyG,KAAK,SAAS,CAAC9B,EAAShE,GAEhC,CAIS,0BAAA6F,GACR,MAAMtC,EAAkBlE,KAAKH,YAAYsE,UACzC,IAAK,IAAIC,EAAIF,EAAUtC,OAAO,EAAGwC,GAAK,EAAGA,IAAK,CAC5C,MAAM3B,EAAmByB,EAAUE,GAC/BpE,KAAKoD,kBAAkBX,IACzBzC,KAAKH,YAAY8B,OAAOyC,EAE3B,CACF,CAIS,0BAAAhC,CAA4BP,GACpC,MAAMqC,EAAgClE,KAAKH,YAAYsE,UACvD,IAAK,IAAIC,EAAIF,EAAUtC,OAAO,EAAGwC,GAAK,EAAGA,IAAK,CACLF,EAAUE,GAChCvC,MAAQA,GACvB7B,KAAKH,YAAY8B,OAAOyC,EAE3B,CACF,CAIS,2BAAA1C,GACR,IAAIgF,EAAqBtG,KAAKC,MAAQZ,EAAkBO,KAAKF,gBAE7D,MAAMoE,EAAgClE,KAAKH,YAAYsE,UACvD,IAAK,IAAIC,EAAIF,EAAUtC,OAAO,EAAGwC,GAAK,EAAGA,IAAK,CAC5C,MAAM3B,EAAiCyB,EAAUE,KAE5C,UAAW3B,IACbA,EAAaT,UAAY0E,IAE1B1G,KAAKM,SAASqB,OAAOc,EAAaZ,KAClC7B,KAAKH,YAAY8B,OAAOyC,GAE3B,CACF,CAIS,wBAAAtC,CAA0BE,GAClC,IAAI6C,EAAsBtB,KAAKuB,IAAI9E,KAAKG,cAAgB,EAAG6B,GAC3D,GAAI6C,GAAgBE,OAAOC,iBACzB,MAAM,IAAIC,UAAU,2CAEpBjF,KAAKG,cAAgB0E,CAExB"}