{"version":3,"file":"LWWMap.umd.js","sources":["../src/LWWMap.ts"],"sourcesContent":["  import * as Y         from 'yjs'\n  import { Observable } from 'lib0/observable'\n  import md5            from 'blueimp-md5'\n\n  const TimestampFactor = 3000              // expected max. # of changes per ms\n         // however, having even more changes does not break this implementation\n\n  type ChangeLogEntry<T> = {              // represents a change of an LWWMap entry\n    Key:string,\n    Value?:T,\n    Timestamp:number\n  }\n\n// handling of deleted entries:\n// - entries in this.localMap and this.sharedArray with missing \"Value\" property\n//   such entries will be removed \"RetentionPeriod\" ms after deletion\n\n  export class LWWMap<T extends object|boolean|Array<T>|string|number|null|Uint8Array> extends Observable<T> {\n    protected RetentionPeriod:number    // how long to keep deletion log entries\n    protected sharedArray:any  // elements with higher indices where added later\n    protected localMap:Map<string,ChangeLogEntry<T>> // caches validated changes\n    protected lastTimestamp:number       // keeps track of most recent timestamp\n\n    public constructor (\n      sharedArray:Y.Array<{ key: string, val: T }>,\n      RetentionPeriod:number = 30*24*60*60*1000\n    ) {\n      super()\n\n      this.sharedArray = sharedArray       // this is the actually shared object\n\n      this.RetentionPeriod = RetentionPeriod * TimestampFactor\n      this.lastTimestamp   = Date.now()      * TimestampFactor\n\n      this.localMap = new Map<string,ChangeLogEntry<T>>()\n      this._initializeMap()\n\n    /**** \"sharedArray\" is where synchronization happens, observe it ****/\n\n      this.sharedArray.observe(\n        (Event:any,Transaction:any) => this._updateOnChange(Event,Transaction)\n      )\n    }\n\n  /**** @@iterator ****/\n\n    public [Symbol.iterator]():IterableIterator<T> {\n      return (\n        [...this.localMap.entries()]\n        .filter((Entry) => 'Value' in Entry[1])\n        .map((Entry) => [Entry[0],Entry[1].Value])\n      )[Symbol.iterator]() as IterableIterator<T>\n    }\n\n  /**** size ****/\n\n    public get size ():number {\n      let Result:number = 0\n        this.localMap.forEach((loggedEntry:ChangeLogEntry<T>) => {\n          if ('Value' in loggedEntry) { Result++ }\n        })\n      return Result\n    }\n\n  /**** clear ****/\n\n    public clear ():void {\n      if (this.size > 0) {\n        this.sharedArray.doc.transact(() => {\n          this._removeAnyObsoleteDeletions()    // from localMap and sharedArray\n\n          this.sharedArray.delete(0,this.sharedArray.length)\n\n          this.localMap.forEach((loggedEntry:ChangeLogEntry<T>, Key:string) => {\n            if ('Value' in loggedEntry) {\n              this._updateLastTimestampWith(Date.now() * TimestampFactor)\n              let Change:ChangeLogEntry<T> = { Key, Timestamp:this.lastTimestamp }\n\n              this.localMap.set(Key,Change)\n              this.sharedArray.push([Change])\n            } else {\n              this.sharedArray.push([loggedEntry])\n            }\n          })\n        })\n      }\n    }\n\n  /**** delete ****/\n\n    public delete (Key:string):boolean {\n      if (this.localMap.has(Key)) {       // ignore deletions of missing entries\n        this.sharedArray.doc.transact(() => {\n          this._removeAnyLogEntriesForKey(Key)\n          this._removeAnyObsoleteDeletions()\n\n          this._updateLastTimestampWith(Date.now() * TimestampFactor)\n          let Change:ChangeLogEntry<T> = { Key, Timestamp:this.lastTimestamp }\n\n          this.localMap.set(Key,Change)\n          this.sharedArray.push([Change])\n        })\n\n        return true\n      } else {\n        return false\n      }\n    }\n\n  /**** entries ****/\n\n    public entries ():IterableIterator<[string, T]> {\n      const localMapEntries = this.localMap.entries()\n\n      return {\n        [Symbol.iterator]() { return this },       // makes this object iterable\n\n// @ts-ignore TS2322\n        next: ():{ value?:[string,T], done?:boolean } => {\n          let nextEntry = localMapEntries.next()\n          while (! nextEntry.done) {\n            let [Key,loggedChange] = nextEntry.value\n            if ('Value' in loggedChange) {\n              return { value:[Key,loggedChange.Value as T] }\n            } else {\n              nextEntry = localMapEntries.next()\n            }\n          }\n          return { done:true }\n        }\n      }\n    }\n\n  /**** forEach ****/\n\n    public forEach (Callback:(Value:T, Key:string, Map:LWWMap<T>) => void, thisArg?:any):void {\n      this.localMap.forEach((loggedEntry:ChangeLogEntry<T>,Key:string) => {\n        if ('Value' in loggedEntry) {     // ignore entries describing deletions\n          Callback.call(thisArg, loggedEntry.Value as T, Key, this)\n        }\n      })\n    }\n\n  /**** get ****/\n\n    public get (Key:string):T | undefined {\n      return (\n        this.localMap.has(Key)\n        ? (this.localMap.get(Key) as ChangeLogEntry<T>).Value\n        : undefined\n      )\n    }\n\n  /**** has ****/\n\n    public has (Key:string):boolean {\n      return (\n        this.localMap.has(Key) &&\n        ('Value' in (this.localMap.get(Key) as ChangeLogEntry<T>))\n      )\n    }\n\n  /**** keys ****/\n\n    public keys ():IterableIterator<string> {\n      const localMapEntries = this.localMap.entries()\n\n      return {\n        [Symbol.iterator]() { return this },       // makes this object iterable\n\n// @ts-ignore TS2322\n        next: ():{ value?:string, done?:boolean } => {\n          let nextEntry = localMapEntries.next()\n          while (! nextEntry.done) {\n            let [Key,loggedChange] = nextEntry.value\n            if ('Value' in loggedChange) {\n              return { value:Key }\n            } else {\n              nextEntry = localMapEntries.next()\n            }\n          }\n          return { done:true }\n        }\n      }\n    }\n\n  /**** set ****/\n\n    public set (Key:string, Value:T):void {\n      this.sharedArray.doc.transact(() => {\n        this._removeAnyLogEntriesForKey(Key)\n        this._removeAnyObsoleteDeletions()\n\n        this._updateLastTimestampWith(Date.now() * TimestampFactor)\n        let Change = { Key, Value, Timestamp:this.lastTimestamp }\n\n        this.localMap.set(Key,Change)\n        this.sharedArray.push([Change])\n      })\n    }\n\n  /**** values ****/\n\n    public values ():IterableIterator<T> {\n      const localMapEntries = this.localMap.entries()\n\n      return {\n        [Symbol.iterator]() { return this },       // makes this object iterable\n\n// @ts-ignore TS2322\n        next: ():{ value?:T, done?:boolean } => {\n          let nextEntry = localMapEntries.next()\n          while (! nextEntry.done) {\n            let [Key,loggedChange] = nextEntry.value\n            if ('Value' in loggedChange) {\n              return { value:loggedChange.Value as T }\n            } else {\n              nextEntry = localMapEntries.next()\n            }\n          }\n          return { done:true }\n        }\n      }\n    }\n\n  /**** transact ****/\n\n    public transact (Callback:(Transaction:any) => void, Origin?:any):void {\n      this.sharedArray.doc.transact(Callback,Origin)\n    }\n\n  /**** Container ****/\n\n    public get Container ():Y.Array<{ key: string, val: T }> {\n      return this.sharedArray\n    }\n\n  /**** _LogEntryIsBroken ****/\n\n    protected _LogEntryIsBroken (LogEntry:any):boolean {\n      return (\n        (LogEntry == null) ||\n        (typeof LogEntry.Key !== 'string') ||\n        (typeof LogEntry.Timestamp !== 'number') ||\n        ! isFinite(LogEntry.Timestamp) || (LogEntry.Timestamp < 0) ||\n        (Math.floor(LogEntry.Timestamp) !== LogEntry.Timestamp)\n      )\n    }\n\n  /**** _ChangesCollide - is \"firstChange\" newer than \"secondChange\"? ****/\n\n    private _md5Hash (Value:any):string {\n      try {\n        return md5(JSON.stringify(Value))\n      } catch (Signal:any) {\n        return ''\n      }\n    }\n\n    protected _ChangesCollide (\n      firstChange:ChangeLogEntry<T>, secondChange:ChangeLogEntry<T>\n    ):boolean {\n      return (\n        (firstChange.Timestamp > secondChange.Timestamp) ||\n        (\n          (firstChange.Timestamp === secondChange.Timestamp) &&\n          (firstChange.Value !== secondChange.Value) &&\n          (this._md5Hash(firstChange.Value) > this._md5Hash(secondChange.Value))\n        )                // consistent behaviour in case of timestamp collisions\n      )\n    }\n\n  /**** initialize \"localMap\" from \"sharedArray\", remove obsolete array items ****/\n\n    protected _initializeMap ():void {\n      const DeletionSet = new Map()              // keeps track of deletion logs\n\n      const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n      this.sharedArray.doc.transact(() => {\n        for (let i = ChangeLog.length-1; i >= 0; i--) {// backwards for deletion\n          const loggedChange:ChangeLogEntry<T> = ChangeLog[i]\n\n          const Key          = loggedChange.Key\n          const KeyIsKnown   = this.localMap.has(Key) || DeletionSet.has(Key)\n          const cachedChange = (\n            KeyIsKnown\n            ? this.localMap.get(Key) || DeletionSet.get(Key)\n            : undefined\n          )\n\n          if ('Value' in loggedChange) {// \"loggedChange\" defines existing entry\n            switch (true) {\n              case ! KeyIsKnown:\n                this.localMap.set(Key,loggedChange)\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n                break\n              case this._ChangesCollide(cachedChange,loggedChange):\n                console.warn(\n                  'LWWMap: timestamp mismatch for key \"' + Key + '\"'\n                )\n                this.sharedArray.delete(i)          // remove obsolete log entry\n                break\n              default:      // entry is already known, but its state is outdated\n                DeletionSet.delete(Key)                       // just in case...\n\n                this.localMap.set(Key,loggedChange)\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n            }        // the older ChangeLog entry will persist until next update\n          } else {                     // \"loggedChange\" defines a deleted entry\n            switch (true) {\n              case ! KeyIsKnown:\n                DeletionSet.set(Key,loggedChange)\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n                break\n              case this._ChangesCollide(cachedChange,loggedChange):\n                console.warn(\n                  'LWWMap: timestamp mismatch for key \"' + Key + '\"'\n                )\n                this.sharedArray.delete(i)          // remove obsolete log entry\n                break\n              default:      // entry is already known, but its state is outdated\n                DeletionSet.set(Key,loggedChange)\n\n                this.localMap.delete(Key)                     // just in case...\n                this._updateLastTimestampWith(loggedChange.Timestamp)\n            }        // the older ChangeLog entry will persist until next update\n          }\n        }\n      })\n    }\n\n  /**** apply reported updates - if applicable ****/\n\n    protected _updateOnChange (Event:any,Transaction:any):void {\n      const TransactionLog  = new Map()  // verified updates in this transaction\n      let   TransactionTime = this.lastTimestamp          // temporary timestamp\n      const EventLog        = new Map()           // prepares final change event\n\n    /**** updateTransactionTimeWith ****/\n\n      function updateTransactionTimeWith (newTimestamp:number):void {\n        TransactionTime = Math.max(TransactionTime,newTimestamp)\n        if (TransactionTime >= Number.MAX_SAFE_INTEGER) {\n          throw new TypeError('timestamp has reached the allowed limit')\n        }\n      }\n\n    /**** analyze all updates in this transaction ****/\n\n      const UpdateLog:ChangeLogEntry<T>[] = Array.from(Event.changes.added).map(\n        (addedContent:any) => addedContent.content.getContent()\n      ).flat()                      // updates are appended sharedArray elements\n\n      try {\n        UpdateLog.forEach((loggedUpdate:ChangeLogEntry<T>) => {\n          if (this._LogEntryIsBroken(loggedUpdate)) { return } // skip broken logs\n\n          const Key          = loggedUpdate.Key\n          const KeyIsKnown   = EventLog.has(Key) || this.localMap.has(Key)\n          const cachedUpdate = (\n            KeyIsKnown\n            ? EventLog.get(Key) || this.localMap.get(Key)\n            : undefined\n          )\n\n          switch (true) {\n            case ! ('Value' in loggedUpdate):    // log entry defines a deletion\n              if (KeyIsKnown) {           // actually delete cached entries only\n                if (this._ChangesCollide(cachedUpdate,loggedUpdate)) {\n                \tconsole.warn(\n                \t  'LWWMap: remotely deleted entry was later modified locally',\n                \t  cachedUpdate.Timestamp,loggedUpdate.Timestamp\n                \t)\n                \treturn\n                }\n\n                updateTransactionTimeWith(loggedUpdate.Timestamp)\n\n                TransactionLog.set(Key,loggedUpdate)\n                EventLog.set(Key, {\n                  action:'delete', oldValue:cachedUpdate.Value\n                })\n              }\n              break\n            case KeyIsKnown && this._ChangesCollide(cachedUpdate,loggedUpdate):\n              console.warn(\n                'LWWMap: remote change is outdated',\n                cachedUpdate.Timestamp,loggedUpdate.Timestamp\n              )\n              return\n            default:                                      // everything seems ok\n              updateTransactionTimeWith(loggedUpdate.Timestamp)\n\n              TransactionLog.set(Key,loggedUpdate)\n              if (this.localMap.has(Key)) {             // not just \"KeyIsKnown\"\n                EventLog.set(Key, {\n                  action:'update', oldValue:cachedUpdate.Value, newValue:loggedUpdate.Value\n                })\n              } else {\n                EventLog.set(Key, {\n                  action:'add', newValue:loggedUpdate.Value\n                })\n              }\n          }\n        })\n      } catch (Signal:any) { // refresh affected entries to keep them consistent\n        if (Signal.message.startsWith('Conflict: ')) {\n          const KeysToRefresh   = new Set()\n          const ChangesToDelete = new Set()\n\n          UpdateLog.forEach((loggedUpdate) => {\n            KeysToRefresh.add(loggedUpdate.Key)      // refresh affected entries\n            ChangesToDelete.add(loggedUpdate) // remove inconsistent change logs\n          })\n\n          const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n          this.sharedArray.doc.transact(() => {\n            const ChangesToRefresh = new Map()\n\n          /**** remove any obsolete ChangeLog entries... ****/\n\n            for (let i = ChangeLog.length-1; i >= 0; i--) {// backw. for deletion\n              let loggedChange = ChangeLog[i]\n              let Key          = loggedChange.Key\n\n              switch (true) {\n                case ChangesToDelete.has(loggedChange):\n                  this.sharedArray.delete(i)\n                  break\n                case KeysToRefresh.has(Key):\n                  if (! ChangesToRefresh.has(Key)) {\n                    ChangesToRefresh.set(Key,loggedChange)\n                  }   // \"ChangesToRefresh\" will only store latest logged change\n                  this.sharedArray.delete(i)\n              }\n            }\n\n          /**** ...and reappend those that should be refreshed ****/\n\n            for (const [Key,loggedChange] of ChangesToRefresh) {\n              this.sharedArray.push([loggedChange])\n            }\n          })\n\n          return                                 // no updates have been applied\n        } else {\n          throw Signal                       // do not swallow \"real\" exceptions\n        }\n      }\n\n    /**** now actually apply any updates ****/\n\n      if (EventLog.size > 0) {\n        for (const [Key,loggedUpdate] of TransactionLog) {\n          this.localMap.set(Key,loggedUpdate)\n        }\n        this.lastTimestamp = TransactionTime\n      }\n\n    /**** finally try to optimize the current ChangeLog ****/\n\n      this._removeAnyBrokenLogEntries()\n      this._removeAnyObsoleteDeletions()\n\n      if (EventLog.size > 0) {\n        const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n        this.sharedArray.doc.transact(() => {\n          for (let i = ChangeLog.length-1; i >= 0; i--) { // backw. for deletion\n            const loggedChange = ChangeLog[i]\n            const Key          = loggedChange.Key\n            if (EventLog.has(Key) && (EventLog.get(Key).newValue !== loggedChange.Value)) {\n              this.sharedArray.delete(i)\n            }\n          }\n        })\n      }\n\n    /**** it's time to inform the client ****/\n\n      if (EventLog.size > 0) {\n// @ts-ignore TS2339\n        this.emit('change',[EventLog,Transaction])\n      }\n    }\n\n  /**** _removeAnyBrokenLogEntries ****/\n\n    protected _removeAnyBrokenLogEntries ():void {\n      const ChangeLog:any[] = this.sharedArray.toArray()\n      for (let i = ChangeLog.length-1; i >= 0; i--) {\n        const loggedChange:any = ChangeLog[i]\n        if (this._LogEntryIsBroken(loggedChange)) {\n          this.sharedArray.delete(i)\n        }\n      }\n    }\n\n  /**** _removeAnyLogEntriesForKey ****/\n\n    protected _removeAnyLogEntriesForKey (Key:string):void {\n      const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n      for (let i = ChangeLog.length-1; i >= 0; i--) {\n        const loggedChange:ChangeLogEntry<T> = ChangeLog[i]\n        if (loggedChange.Key === Key) {\n          this.sharedArray.delete(i)\n        }\n      }\n    }\n\n  /**** _removeAnyObsoleteDeletions ****/\n\n    protected _removeAnyObsoleteDeletions ():void {\n      let RetentionTimestamp = Date.now() * TimestampFactor - this.RetentionPeriod\n\n      const ChangeLog:ChangeLogEntry<T>[] = this.sharedArray.toArray()\n      for (let i = ChangeLog.length-1; i >= 0; i--) {\n        const loggedChange:ChangeLogEntry<T> = ChangeLog[i]\n        if (\n          ! ('Value' in loggedChange) &&\n          (loggedChange.Timestamp < RetentionTimestamp)\n        ) {\n          this.localMap.delete(loggedChange.Key)\n          this.sharedArray.delete(i)\n        }\n      }\n    }\n\n  /**** _updateLastTimestampWith ****/\n\n    protected _updateLastTimestampWith (Timestamp:number):void {\n      let newTimestamp:number = Math.max(this.lastTimestamp + 1, Timestamp)\n      if (newTimestamp >= Number.MAX_SAFE_INTEGER) {\n        throw new TypeError('timestamp has reached the allowed limit')\n      } else {\n        this.lastTimestamp = newTimestamp\n      }\n    }\n  }\n"],"names":["TimestampFactor","LWWMap","Observable","constructor","sharedArray","RetentionPeriod","super","this","lastTimestamp","Date","now","localMap","Map","_initializeMap","observe","Event","Transaction","_updateOnChange","Symbol","iterator","entries","filter","Entry","map","Value","size","Result","forEach","loggedEntry","clear","doc","transact","_removeAnyObsoleteDeletions","delete","length","Key","_updateLastTimestampWith","Change","Timestamp","set","push","has","_removeAnyLogEntriesForKey","localMapEntries","next","nextEntry","done","loggedChange","value","Callback","thisArg","call","get","undefined","keys","values","Origin","Container","_LogEntryIsBroken","LogEntry","isFinite","Math","floor","_md5Hash","md5","JSON","stringify","Signal","_ChangesCollide","firstChange","secondChange","DeletionSet","ChangeLog","toArray","i","KeyIsKnown","cachedChange","console","warn","TransactionLog","TransactionTime","EventLog","updateTransactionTimeWith","newTimestamp","max","Number","MAX_SAFE_INTEGER","TypeError","UpdateLog","Array","from","changes","added","addedContent","content","getContent","flat","loggedUpdate","cachedUpdate","action","oldValue","newValue","message","startsWith","KeysToRefresh","Set","ChangesToDelete","add","ChangesToRefresh","_removeAnyBrokenLogEntries","emit","RetentionTimestamp"],"mappings":"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"}